// build_pipeline.cpp - Build pipeline implementation
#include "driver/build_pipeline.h"
#include "driver/linker_driver.h"
#include <iostream>
#include <sstream>
#include <cstdlib>

namespace cimple {
namespace driver {

BuildPipeline::BuildPipeline()
    : optimization_level_(2),
      dead_code_elimination_(true) {
}

void BuildPipeline::add_source(const std::string& source_file) {
    source_files_.push_back(source_file);
}

void BuildPipeline::set_output(const std::string& output_name) {
    output_name_ = output_name;
}

void BuildPipeline::set_optimization_level(int level) {
    optimization_level_ = level;
}

void BuildPipeline::enable_dead_code_elimination(bool enable) {
    dead_code_elimination_ = enable;
}

bool BuildPipeline::build() {
    if (source_files_.empty()) {
        std::cerr << "[build] No source files to compile\n";
        return false;
    }

    if (output_name_.empty()) {
        // Default output name from first source file
        std::string first_source = source_files_[0];
        size_t dot = first_source.find_last_of('.');
        if (dot != std::string::npos) {
            output_name_ = first_source.substr(0, dot);
        } else {
            output_name_ = first_source;
        }
#ifdef _WIN32
        output_name_ += ".exe";
#endif
    }

    std::vector<std::string> obj_files;

    // Compile each source file
    for (const auto& source : source_files_) {
        std::string obj_file;
        if (!compile_source(source, obj_file)) {
            std::cerr << "[build] Failed to compile " << source << "\n";
            return false;
        }
        obj_files.push_back(obj_file);
    }

    // Link all object files
    return link_objects(obj_files);
}

bool BuildPipeline::compile_source(const std::string& source_file, std::string& obj_file) {
    // Extract base name
    std::string base = source_file;
    size_t dot = base.find_last_of('.');
    if (dot != std::string::npos) {
        base = base.substr(0, dot);
    }

#ifdef _WIN32
    obj_file = base + ".obj";
#else
    obj_file = base + ".o";
#endif

    std::cout << "[build] Compiling " << source_file << " -> " << obj_file << "\n";

    // For now, this is a placeholder
    // In a full implementation, this would call the Cimple compiler
    // For now, we assume object files are already generated by the compiler
    // This function would invoke: cimple build source_file.cimp
    
    return true; // Assume success for now
}

bool BuildPipeline::link_objects(const std::vector<std::string>& obj_files) {
    LinkerDriver linker;
    
    for (const auto& obj : obj_files) {
        linker.add_object_file(obj);
    }
    
    linker.set_output(output_name_);
    linker.enable_dead_code_elimination(dead_code_elimination_);
    
    std::cout << "[build] Linking " << obj_files.size() << " object file(s) -> " << output_name_ << "\n";
    
    return linker.link();
}

} // namespace driver
} // namespace cimple
